<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>picotm: Transactional Stacks</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">Transactional Stacks</div>  </div>
</div><!--header-->
<div class="contents">

<p>The transactional stack provides a transaction-safe implementation of a single-ended LIFO stack. Efficient insert and remove operations are supported on the same end.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:d9/dd1/a00398"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd1/a00398.html">picotm-txstack-state.h</a></td></tr>
<tr class="memdesc:d9/dd1/a00398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides non-transactional state and entries for transactional stacks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d7/d00/a00401"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/d00/a00401.html">picotm-txstack.h</a></td></tr>
<tr class="memdesc:d7/d00/a00401"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides transactional stacks. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Stack entries are represented by <code>struct <a class="el" href="../../d0/da2/a00796.html" title="Represents an entry in a transaction-safe stack. ">txstack_entry</a></code>. We can add an instance of this data structure to any data value to turn it into a stack entry. Here's an example for stacks of values of type <code>unsigned long</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ulong_item {</div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/da2/a00796.html" title="Represents an entry in a transaction-safe stack. ">txstack_entry</a> stack_entry;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">ulong_item_init(<span class="keyword">struct</span> ulong_item* item, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value)</div><div class="line">{</div><div class="line">    <a class="code" href="../../d9/dd1/a00398.html#a76d3ddea155263f8d8bcf67e3f4c5c87" title="Initializes an entry of a transactional stack. ">txstack_entry_init</a>(&amp;item-&gt;stack_entry);</div><div class="line">    item-&gt;value = value;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>ulong_item item;</div><div class="line"></div><div class="line">ulong_item_init(&amp;item, 0);</div></div><!-- fragment --><p>This code initializes the stack entry using <code><a class="el" href="../../d9/dd1/a00398.html#a76d3ddea155263f8d8bcf67e3f4c5c87" title="Initializes an entry of a transactional stack. ">txstack_entry_init()</a></code>. The macro <code>TXSTACK_ENTRY_INITIALIZER</code> initializes static or stack-allocated stack entries. The example below illustrates this.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ulong_item {</div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/da2/a00796.html" title="Represents an entry in a transaction-safe stack. ">txstack_entry</a> stack_entry;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define ULONG_ITEM_INITIALIZER(_value)  \</span></div><div class="line"><span class="preprocessor">{                                       \</span></div><div class="line"><span class="preprocessor">    TXSTACK_ENTRY_INITIALIZER,          \</span></div><div class="line"><span class="preprocessor">    (_value)                            \</span></div><div class="line"><span class="preprocessor">}</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>ulong_item item = ULONG_ITEM_INITIALIZER(0);</div></div><!-- fragment --><p>When both, macro and function initializers, are possible, the macro form is prefered. Stack entries are uninitialized with <code><a class="el" href="../../d9/dd1/a00398.html#a0e69cb97981ecd308be8e5fe0df9e938" title="Cleans up an entry of a transactional stack. ">txstack_entry_uninit()</a></code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">ulong_item_uninit(<span class="keyword">struct</span> ulong_item* item)</div><div class="line">{</div><div class="line">    <a class="code" href="../../d9/dd1/a00398.html#a0e69cb97981ecd308be8e5fe0df9e938" title="Cleans up an entry of a transactional stack. ">txstack_entry_uninit</a>(&amp;item-&gt;stack_entry);</div><div class="line">}</div><div class="line"></div><div class="line">ulong_item_uninit(&amp;item);</div></div><!-- fragment --><p>To store the stack entries, we need non-transactional stack state, which represents the shared state of a stack. It's implemented by <code>struct <a class="el" href="../../d1/dd1/a00804.html" title="The global state of transaction-safe stack. ">txstack_state</a></code>. We can define and initialize a stack state as illustrated in the example below.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="../../d1/dd1/a00804.html" title="The global state of transaction-safe stack. ">txstack_state</a> stack_state;</div><div class="line"></div><div class="line"><a class="code" href="../../d9/dd1/a00398.html#ab3d8c22053a22db9a4e383fe1fab7438" title="Initializes stack state. ">txstack_state_init</a>(&amp;stack_state);</div></div><!-- fragment --><p>This code uses the initializer function <code><a class="el" href="../../d9/dd1/a00398.html#ab3d8c22053a22db9a4e383fe1fab7438" title="Initializes stack state. ">txstack_state_init()</a></code>. For static or stack-allocated stack states, there's the initializer macro <code><a class="el" href="../../d9/dd1/a00398.html#a16c0c5bd3c7a910faa179e6daf29e118" title="Initializer macro for struct txstack_state. ">TXSTACK_STATE_INITIALIZER()</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="../../d1/dd1/a00804.html" title="The global state of transaction-safe stack. ">txstack_state</a> stack_state =</div><div class="line">    <a class="code" href="../../d9/dd1/a00398.html#a16c0c5bd3c7a910faa179e6daf29e118" title="Initializer macro for struct txstack_state. ">TXSTACK_STATE_INITIALIZER</a>(stack_state);</div></div><!-- fragment --><p>When both forms are possible, the initializer macro is prefered.</p>
<p>Stack-state clean-up is performed by <code><a class="el" href="../../d9/dd1/a00398.html#aa8b99ad2f876a8f0e558d0e7c7bea0ed" title="Cleans up stack state. ">txstack_state_uninit()</a></code>. The stack state may not contain entries when the clean-up happens. This means that entries have to be cleaned up from within a transaction.</p>
<p>For many uses, this requirement just imposes unnecessary overhead. A call to <code><a class="el" href="../../d9/dd1/a00398.html#a3de40ba3a923da32f0e5f7f5db1d8d70" title="Removes all entries from a stack state and runs a cleanup function on each. ">txstack_state_clear_and_uninit_entries()</a></code> provies a non-transactional way of clearing the stack from its entries. It erases each element from the stack and calls a clean-up function on it. The example below shows the clean-up code for a stack of <code>struct ulong_item</code> entries.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ulong_item*</div><div class="line">ulong_item_of_entry(<span class="keyword">struct</span> <a class="code" href="../../d0/da2/a00796.html" title="Represents an entry in a transaction-safe stack. ">txstack_entry</a>* entry)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="../../d2/de7/a00014.html#ac5d7110fe4aca39bb1fce3b46b2a1c3c">picotm_containerof</a>(entry, <span class="keyword">struct</span> ulong_item, stack_entry);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">ulong_item_uninit_cb(<span class="keyword">struct</span> <a class="code" href="../../d0/da2/a00796.html" title="Represents an entry in a transaction-safe stack. ">txstack_entry</a>* entry, <span class="keywordtype">void</span>* data)</div><div class="line">{</div><div class="line">    ulong_item_uninit(ulong_item_of_entry(entry));</div><div class="line"></div><div class="line">    <span class="comment">// call free() if item was malloc()&#39;ed</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="../../d9/dd1/a00398.html#a3de40ba3a923da32f0e5f7f5db1d8d70" title="Removes all entries from a stack state and runs a cleanup function on each. ">txstack_state_clear_and_uninit_entries</a>(&amp;stack_state, ulong_item_uninit_cb, NULL);</div><div class="line"><a class="code" href="../../d9/dd1/a00398.html#aa8b99ad2f876a8f0e558d0e7c7bea0ed" title="Cleans up stack state. ">txstack_state_uninit</a>(&amp;stack_state);</div></div><!-- fragment --><p>At this point we have a stack state and stack entries to add to the state. So far all code was non-transactional. Actual stack access and manipulation is performed by transactional code.</p>
<p>To perform stack operations within a transaction, we first need a stack data structure for our transaction. It's represented by <code>struct txstack</code>. A call to <code><a class="el" href="../../d7/d00/a00401.html#a7e9c348d5615a1bef319350b935b541b" title="Creates a transactional stack for a stack state. ">txstack_of_state_tx()</a></code> returns an instance.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d8/dbb/a00932.html" title="A handle for operating on transaction-safe stacks. ">txstack</a>* stack = <a class="code" href="../../d7/d00/a00401.html#a7e9c348d5615a1bef319350b935b541b" title="Creates a transactional stack for a stack state. ">txstack_of_state_tx</a>(&amp;stack_state);</div><div class="line"></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>Calling <code><a class="el" href="../../d7/d00/a00401.html#a7e9c348d5615a1bef319350b935b541b" title="Creates a transactional stack for a stack state. ">txstack_of_state_tx()</a></code> multiple times for the same stack state <em>within the same transaction</em> returns the same stack. Stacks are undefined after their transaction committed or aborted, or within other, concurrent transactions.</p>
<p>With the stack, we can now put entries onto the stack state using <code><a class="el" href="../../d7/d00/a00401.html#a112601800b67c882e434596d731bb16a" title="Inserts an entry at the top of a transactional stack. ">txstack_push_tx()</a></code>. The example below illustrates this.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d8/dbb/a00932.html" title="A handle for operating on transaction-safe stacks. ">txstack</a>* stack = <a class="code" href="../../d7/d00/a00401.html#a7e9c348d5615a1bef319350b935b541b" title="Creates a transactional stack for a stack state. ">txstack_of_state_tx</a>(&amp;stack_state);</div><div class="line"></div><div class="line">    <a class="code" href="../../d7/d00/a00401.html#a112601800b67c882e434596d731bb16a" title="Inserts an entry at the top of a transactional stack. ">txstack_push_tx</a>(stack, &amp;item-&gt;stack_entry);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>After this transaction committed, the ulong data item <code>item</code> will be the final entry in <code>stack_state</code>. If the transactions has to abort after the call to <code><a class="el" href="../../d7/d00/a00401.html#a112601800b67c882e434596d731bb16a" title="Inserts an entry at the top of a transactional stack. ">txstack_push_tx()</a></code>, the transaction framework will automatically remove the pushed entry during the rollback; thus restoring the original state.</p>
<p>To remove the top-most entry from the stack, we can call <code><a class="el" href="../../d7/d00/a00401.html#ac94eb1e2ba5eb73031b8e7a16f902922" title="Removes the top-most entry of a transactional stack. ">txstack_pop_tx()</a></code>. This call is often combined with <code><a class="el" href="../../d7/d00/a00401.html#ab7da8ff954ef25166bec4fec781e7806" title="Returns the top-most entry of a transactional stack. ">txstack_top_tx()</a></code>, which returns the stack's top-most entry. The combination is illustated in the example below.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d8/dbb/a00932.html" title="A handle for operating on transaction-safe stacks. ">txstack</a>* stack = <a class="code" href="../../d7/d00/a00401.html#a7e9c348d5615a1bef319350b935b541b" title="Creates a transactional stack for a stack state. ">txstack_of_state_tx</a>(&amp;stack_state);</div><div class="line"></div><div class="line">    <span class="comment">// The stack state already contains the entry.</span></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/da2/a00796.html" title="Represents an entry in a transaction-safe stack. ">txstack_entry</a>* entry = <a class="code" href="../../d7/d00/a00401.html#ab7da8ff954ef25166bec4fec781e7806" title="Returns the top-most entry of a transactional stack. ">txstack_top_tx</a>(stack);</div><div class="line">    <a class="code" href="../../d7/d00/a00401.html#ac94eb1e2ba5eb73031b8e7a16f902922" title="Removes the top-most entry of a transactional stack. ">txstack_pop_tx</a>(stack);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>As usual, all errors are detected and handled by the transaction framework. The benefits of transactional code show when we move entries between stacks.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d8/dbb/a00932.html" title="A handle for operating on transaction-safe stacks. ">txstack</a>* src_stack = <a class="code" href="../../d7/d00/a00401.html#a7e9c348d5615a1bef319350b935b541b" title="Creates a transactional stack for a stack state. ">txstack_of_state_tx</a>(&amp;src_stack_state);</div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d8/dbb/a00932.html" title="A handle for operating on transaction-safe stacks. ">txstack</a>* dst_stack = <a class="code" href="../../d7/d00/a00401.html#a7e9c348d5615a1bef319350b935b541b" title="Creates a transactional stack for a stack state. ">txstack_of_state_tx</a>(&amp;dst_stack_state);</div><div class="line"></div><div class="line">    <span class="comment">// The stack state already contains the entry.</span></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/da2/a00796.html" title="Represents an entry in a transaction-safe stack. ">txstack_entry</a>* entry = <a class="code" href="../../d7/d00/a00401.html#ab7da8ff954ef25166bec4fec781e7806" title="Returns the top-most entry of a transactional stack. ">txstack_top_tx</a>(src_stack);</div><div class="line">    <a class="code" href="../../d7/d00/a00401.html#ac94eb1e2ba5eb73031b8e7a16f902922" title="Removes the top-most entry of a transactional stack. ">txstack_pop_tx</a>(src_stack);</div><div class="line"></div><div class="line">    <a class="code" href="../../d7/d00/a00401.html#a112601800b67c882e434596d731bb16a" title="Inserts an entry at the top of a transactional stack. ">txstack_push_tx</a>(dst_stack, &amp;item-&gt;stack_entry);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>In this example, we take an entry from a source stack and put it onto a destination stack. The transaction framework automatically isolates these operations from concurrent transactions until the transaction commits. So concurrent transactions see the entry on <em>either</em> the source stack <em>or</em> the destination stack, but never on both. If the transaction has to roll back after the push operation, the transaction framework automatically removes the stack entry from the destination stack and returns it to its old position on the source stack.</p>
<p>A call to <code><a class="el" href="../../d7/d00/a00401.html#af13edd524db5ed5779165097c62300bf" title="Returns the number of entries on a transactional stack. ">txstack_size_tx()</a></code> returns the number of stack entries, a call to <code><a class="el" href="../../d7/d00/a00401.html#ad8cbef385650fa868acc19ac8bd036ab" title="Tests a transactional stack for emptiness. ">txstack_empty_tx()</a></code> returns <code>true</code> if a stack is empty. The former function might have linear complexity, the later function always has constant complexity. It's therefore better to use <code><a class="el" href="../../d7/d00/a00401.html#ad8cbef385650fa868acc19ac8bd036ab" title="Tests a transactional stack for emptiness. ">txstack_empty_tx()</a></code> if it's only relevant whether there are entries.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d8/dbb/a00932.html" title="A handle for operating on transaction-safe stacks. ">txstack</a>* stack = <a class="code" href="../../d7/d00/a00401.html#a7e9c348d5615a1bef319350b935b541b" title="Creates a transactional stack for a stack state. ">txstack_of_state_tx</a>(&amp;stack_state);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> is_empty = <a class="code" href="../../d7/d00/a00401.html#ad8cbef385650fa868acc19ac8bd036ab" title="Tests a transactional stack for emptiness. ">txstack_empty_tx</a>(stack);</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> size = <a class="code" href="../../d7/d00/a00401.html#af13edd524db5ed5779165097c62300bf" title="Returns the number of entries on a transactional stack. ">txstack_size_tx</a>(stack);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d7/db6/a00940.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --> </div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!--
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
-->
</body>
</html>
