<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>picotm: Transactional Queues</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">Transactional Queues</div>  </div>
</div><!--header-->
<div class="contents">

<p>The transactional queue provides a transaction-safe implementation of a single-ended FIFO queue. Efficient insert operations are supported on one end, efficient remove operations are supported on the opposite end.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:dd/dc1/a00212"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/dc1/a00212.html">picotm-txqueue-state.h</a></td></tr>
<tr class="memdesc:dd/dc1/a00212"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides non-transactional state and entries for transactional queues. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d3/dd5/a00215"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dd5/a00215.html">picotm-txqueue.h</a></td></tr>
<tr class="memdesc:d3/dd5/a00215"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides transactional queues. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Queue entries are represented by <code>struct <a class="el" href="../../de/d55/a00323.html" title="Represents an entry in a transaction-safe queue. ">txqueue_entry</a></code>. We can add an instance of this data structure to any data value to turn it into a queue entry. Here's an example for queues of values of type <code>unsigned long</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ulong_item {</div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../de/d55/a00323.html" title="Represents an entry in a transaction-safe queue. ">txqueue_entry</a> queue_entry;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">ulong_item_init(<span class="keyword">struct</span> ulong_item* item, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value)</div><div class="line">{</div><div class="line">    <a class="code" href="../../d3/d42/a00235.html#ga91d05f38923fe30096c92f5ff70db9bc" title="Initializes an entry of a transactional queue. ">txqueue_entry_init</a>(&amp;item-&gt;queue_entry);</div><div class="line">    item-&gt;value = value;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>ulong_item item;</div><div class="line"></div><div class="line">ulong_item_init(&amp;item, 0);</div></div><!-- fragment --><p>This code initializes the queue entry using <code><a class="el" href="../../d3/d42/a00235.html#ga91d05f38923fe30096c92f5ff70db9bc" title="Initializes an entry of a transactional queue. ">txqueue_entry_init()</a></code>. The macro <code>TXQUEUE_ENTRY_INITIALIZER</code> initializes static or stack-allocated queue entries. The example below illustrates this.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ulong_item {</div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../de/d55/a00323.html" title="Represents an entry in a transaction-safe queue. ">txqueue_entry</a> queue_entry;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define ULONG_ITEM_INITIALIZER(_value)  \</span></div><div class="line"><span class="preprocessor">{                                       \</span></div><div class="line"><span class="preprocessor">    TXQUEUE_ENTRY_INITIALIZER,          \</span></div><div class="line"><span class="preprocessor">    (_value)                            \</span></div><div class="line"><span class="preprocessor">}</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>ulong_item item = ULONG_ITEM_INITIALIZER(0);</div></div><!-- fragment --><p>When both, macro and function initializers, are possible, the macro form is prefered. Queue entries are uninitialized with <code><a class="el" href="../../d3/d42/a00235.html#ga019f182c0faaf8b39386f273914af760" title="Cleans up an entry of a transactional queue. ">txqueue_entry_uninit()</a></code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">ulong_item_uninit(<span class="keyword">struct</span> ulong_item* item)</div><div class="line">{</div><div class="line">    <a class="code" href="../../d3/d42/a00235.html#ga019f182c0faaf8b39386f273914af760" title="Cleans up an entry of a transactional queue. ">txqueue_entry_uninit</a>(&amp;item-&gt;queue_entry);</div><div class="line">}</div><div class="line"></div><div class="line">ulong_item_uninit(&amp;item);</div></div><!-- fragment --><p>To store the queue entries, we need non-transactional queue state, which represents the shared state of a queue. It's implemented by <code>struct <a class="el" href="../../d8/df7/a00331.html" title="The global state of transaction-safe queue. ">txqueue_state</a></code>. We can define and initialize a queue state as illustrated in the example below.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="../../d8/df7/a00331.html" title="The global state of transaction-safe queue. ">txqueue_state</a> queue_state;</div><div class="line"></div><div class="line"><a class="code" href="../../d3/d42/a00235.html#ga8290a904bf3222dfbe42381d01554969" title="Initializes queue state. ">txqueue_state_init</a>(&amp;queue_state);</div></div><!-- fragment --><p>This code uses the initializer function <code><a class="el" href="../../d3/d42/a00235.html#ga8290a904bf3222dfbe42381d01554969" title="Initializes queue state. ">txqueue_state_init()</a></code>. For static or stack-allocated queue states, there's the initializer macro <code><a class="el" href="../../d3/d42/a00235.html#ga79afada23ac0c4d01824ce3d62858689" title="Initializer macro for struct txqueue_state. ">TXQUEUE_STATE_INITIALIZER()</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="../../d8/df7/a00331.html" title="The global state of transaction-safe queue. ">txqueue_state</a> queue_state =</div><div class="line">    <a class="code" href="../../d3/d42/a00235.html#ga79afada23ac0c4d01824ce3d62858689" title="Initializer macro for struct txqueue_state. ">TXQUEUE_STATE_INITIALIZER</a>(queue_state);</div></div><!-- fragment --><p>When both forms are possible, the initializer macro is prefered.</p>
<p>Queue-state clean-up is performed by <code><a class="el" href="../../d3/d42/a00235.html#ga8eb8ea809759f4e17214fd21d0e0d1fc" title="Cleans up queue state. ">txqueue_state_uninit()</a></code>. The queue state may not contain entries when the clean-up happens. This means that entries have to be cleaned up from within a transaction.</p>
<p>For many uses, this requirement just imposes unnecessary overhead. A call to <code><a class="el" href="../../d3/d42/a00235.html#ga0edd94d7425aaf76d8009c5f680b34ba" title="Removes all entries from a queue state and runs a cleanup function on each. ">txqueue_state_clear_and_uninit_entries()</a></code> provies a non-transactional way of clearing the queue from its entries. It erases each element from the queue and calls a clean-up function on it. The example below shows the clean-up code for a queue of <code>struct ulong_item</code> entries.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ulong_item*</div><div class="line">ulong_item_of_entry(<span class="keyword">struct</span> <a class="code" href="../../de/d55/a00323.html" title="Represents an entry in a transaction-safe queue. ">txqueue_entry</a>* entry)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="../../dc/d55/a00226.html#gac5d7110fe4aca39bb1fce3b46b2a1c3c">picotm_containerof</a>(entry, <span class="keyword">struct</span> ulong_item, queue_entry);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">ulong_item_uninit_cb(<span class="keyword">struct</span> <a class="code" href="../../de/d55/a00323.html" title="Represents an entry in a transaction-safe queue. ">txqueue_entry</a>* entry, <span class="keywordtype">void</span>* data)</div><div class="line">{</div><div class="line">    ulong_item_uninit(ulong_item_of_entry(entry));</div><div class="line"></div><div class="line">    <span class="comment">// call free() if item was malloc()&#39;ed</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="../../d3/d42/a00235.html#ga0edd94d7425aaf76d8009c5f680b34ba" title="Removes all entries from a queue state and runs a cleanup function on each. ">txqueue_state_clear_and_uninit_entries</a>(&amp;queue_state, ulong_item_uninit_cb, NULL);</div><div class="line"><a class="code" href="../../d3/d42/a00235.html#ga8eb8ea809759f4e17214fd21d0e0d1fc" title="Cleans up queue state. ">txqueue_state_uninit</a>(&amp;queue_state);</div></div><!-- fragment --><p>At this point we have a queue state and queue entries to add to the state. So far all code was non-transactional. Actual queue access and manipulation is performed by transactional code.</p>
<p>To perform queue operations within a transaction, we first need a queue data structure for our transaction. It's represented by <code>struct txqueue</code>. A call to <code><a class="el" href="../../d3/d42/a00235.html#ga24337f47c1f48f6ff42cace86bd49e9b" title="Creates a transactional queue for a queue state. ">txqueue_of_state_tx()</a></code> returns an instance.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gacc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d9/d9b/a00363.html" title="A handle for operating on transaction-safe queues. ">txqueue</a>* queue = <a class="code" href="../../d3/d42/a00235.html#ga24337f47c1f48f6ff42cace86bd49e9b" title="Creates a transactional queue for a queue state. ">txqueue_of_state_tx</a>(&amp;queue_state);</div><div class="line"></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gaa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gacc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>Calling <code><a class="el" href="../../d3/d42/a00235.html#ga24337f47c1f48f6ff42cace86bd49e9b" title="Creates a transactional queue for a queue state. ">txqueue_of_state_tx()</a></code> multiple times for the same queue state <em>within the same transaction</em> returns the same queue. Queues are undefined after their transaction committed or aborted, or within other, concurrent transactions.</p>
<p>With the queue, we can now append entries to the queue state using <code><a class="el" href="../../d3/d42/a00235.html#ga98e016ddaf77e5bc68b6ffb32ee6c1ab" title="Inserts an entry at the front of a transactional queue. ">txqueue_push_tx()</a></code>. The example below illustrates this.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gacc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d9/d9b/a00363.html" title="A handle for operating on transaction-safe queues. ">txqueue</a>* queue = <a class="code" href="../../d3/d42/a00235.html#ga24337f47c1f48f6ff42cace86bd49e9b" title="Creates a transactional queue for a queue state. ">txqueue_of_state_tx</a>(&amp;queue_state);</div><div class="line"></div><div class="line">    <a class="code" href="../../d3/d42/a00235.html#ga98e016ddaf77e5bc68b6ffb32ee6c1ab" title="Inserts an entry at the front of a transactional queue. ">txqueue_push_tx</a>(queue, &amp;item-&gt;queue_entry);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gaa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gacc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>After this transaction committed, the ulong data item <code>item</code> will be the final entry in <code>queue_state</code>. If the transactions has to abort after the call to <code><a class="el" href="../../d3/d42/a00235.html#ga98e016ddaf77e5bc68b6ffb32ee6c1ab" title="Inserts an entry at the front of a transactional queue. ">txqueue_push_tx()</a></code>, the transaction framework will automatically remove the appended entry during the rollback; thus restoring the original state.</p>
<p>To remove the next entry from the queue, we can call <code><a class="el" href="../../d3/d42/a00235.html#ga48a51a7820bfd421a60f64dcf611da7f" title="Removes the last entry of a transactional queue. ">txqueue_pop_tx()</a></code>. This call is often combined with <code><a class="el" href="../../d3/d42/a00235.html#ga946f79883039fa7eb59e0c4b008fbfcf" title="Returns the front-end entry of a transactional queue. ">txqueue_front_tx()</a></code>, which returns the queue's front-end entry. The combination is illustated in the example below.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gacc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d9/d9b/a00363.html" title="A handle for operating on transaction-safe queues. ">txqueue</a>* queue = <a class="code" href="../../d3/d42/a00235.html#ga24337f47c1f48f6ff42cace86bd49e9b" title="Creates a transactional queue for a queue state. ">txqueue_of_state_tx</a>(&amp;queue_state);</div><div class="line"></div><div class="line">    <span class="comment">// The queue state already contains the entry.</span></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../de/d55/a00323.html" title="Represents an entry in a transaction-safe queue. ">txqueue_entry</a>* entry = <a class="code" href="../../d3/d42/a00235.html#ga946f79883039fa7eb59e0c4b008fbfcf" title="Returns the front-end entry of a transactional queue. ">txqueue_front_tx</a>(queue);</div><div class="line">    <a class="code" href="../../d3/d42/a00235.html#ga48a51a7820bfd421a60f64dcf611da7f" title="Removes the last entry of a transactional queue. ">txqueue_pop_tx</a>(queue);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gaa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gacc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>As usual, all errors are detected and handled by the transaction framework. The benefits of transactional code show when we move entries between queues.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gacc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d9/d9b/a00363.html" title="A handle for operating on transaction-safe queues. ">txqueue</a>* src_queue = <a class="code" href="../../d3/d42/a00235.html#ga24337f47c1f48f6ff42cace86bd49e9b" title="Creates a transactional queue for a queue state. ">txqueue_of_state_tx</a>(&amp;src_queue_state);</div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d9/d9b/a00363.html" title="A handle for operating on transaction-safe queues. ">txqueue</a>* dst_queue = <a class="code" href="../../d3/d42/a00235.html#ga24337f47c1f48f6ff42cace86bd49e9b" title="Creates a transactional queue for a queue state. ">txqueue_of_state_tx</a>(&amp;dst_queue_state);</div><div class="line"></div><div class="line">    <span class="comment">// The queue state already contains the entry.</span></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../de/d55/a00323.html" title="Represents an entry in a transaction-safe queue. ">txqueue_entry</a>* entry = <a class="code" href="../../d3/d42/a00235.html#ga946f79883039fa7eb59e0c4b008fbfcf" title="Returns the front-end entry of a transactional queue. ">txqueue_front_tx</a>(src_queue);</div><div class="line">    <a class="code" href="../../d3/d42/a00235.html#ga48a51a7820bfd421a60f64dcf611da7f" title="Removes the last entry of a transactional queue. ">txqueue_pop_tx</a>(src_queue);</div><div class="line"></div><div class="line">    <a class="code" href="../../d3/d42/a00235.html#ga98e016ddaf77e5bc68b6ffb32ee6c1ab" title="Inserts an entry at the front of a transactional queue. ">txqueue_push_tx</a>(dst_queue, &amp;item-&gt;queue_entry);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gaa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gacc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>In this example, we remove an entry from a source source and append it to a destination queue. The transaction framework automatically isolates these operations from concurrent transactions until the transaction commits. So concurrent transactions see the entry in <em>either</em> the source queue <em>or</em> the destination queue, but never in both. If the transaction has to roll back after the append operation, the transaction framework automatically removes the queue entry from the destination queue and returns it to its old position in the source queue.</p>
<p>A call to <code><a class="el" href="../../d3/d42/a00235.html#ga275b149132595935c4e7a2e529700316" title="Returns the number of entries in a transactional queue. ">txqueue_size_tx()</a></code> returns the number of queue entries, a call to <code><a class="el" href="../../d3/d42/a00235.html#ga46ee758ec333f09208406fd4f0c5c46a" title="Tests a transactional queue for emptiness. ">txqueue_empty_tx()</a></code> returns <code>true</code> if a queue is empty. The former function might have linear complexity, the later function always has constant complexity. It's therefore better to use <code><a class="el" href="../../d3/d42/a00235.html#ga46ee758ec333f09208406fd4f0c5c46a" title="Tests a transactional queue for emptiness. ">txqueue_empty_tx()</a></code> if it's only relevant whether there are entries.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gacc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d9/d9b/a00363.html" title="A handle for operating on transaction-safe queues. ">txqueue</a>* queue = <a class="code" href="../../d3/d42/a00235.html#ga24337f47c1f48f6ff42cace86bd49e9b" title="Creates a transactional queue for a queue state. ">txqueue_of_state_tx</a>(&amp;queue_state);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> is_empty = <a class="code" href="../../d3/d42/a00235.html#ga46ee758ec333f09208406fd4f0c5c46a" title="Tests a transactional queue for emptiness. ">txqueue_empty_tx</a>(queue);</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> size = <a class="code" href="../../d3/d42/a00235.html#ga275b149132595935c4e7a2e529700316" title="Returns the number of entries in a transactional queue. ">txqueue_size_tx</a>(queue);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gaa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d01/a00227.html#gacc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --> </div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<!--
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
-->
</body>
</html>
