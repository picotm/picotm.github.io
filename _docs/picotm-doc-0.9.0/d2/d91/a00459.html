<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>picotm: Transactional Multisets</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">picotm
   &#160;<span id="projectnumber">0.9.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#files">Files</a>  </div>
  <div class="headertitle">
<div class="title">Transactional Multisets</div>  </div>
</div><!--header-->
<div class="contents">

<p>The transactional multiset provides a transaction-safe implementation of a multiset. Multisets are sorted sets of elements. Duplicate entries are supported.  
<a href="#details">More...</a></p>
<div class="dynheader">
Collaboration diagram for Transactional Multisets:</div>
<div class="dyncontent">
<center><table><tr><td><img src="../../d2/d91/a00459.png" border="0" alt="" usemap="#d2_2d91_2a00459"/>
<map name="d2_2d91_2a00459" id="d2_2d91_2a00459">
<area shape="rect" id="node2" href="../../d1/dbd/a00457.html" title="The txlib module provides data structures that are safe to use from within transactions and cooperate..." alt="" coords="392,14,563,55"/>
</map>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="files"></a>
Files</h2></td></tr>
<tr class="memitem:d8/d8e/a00344"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d8e/a00344.html">picotm-txmultiset-state.h</a></td></tr>
<tr class="memdesc:d8/d8e/a00344"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides non-transactional state and entries for transactional multisets. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:d1/dc6/a00347"><td class="memItemLeft" align="right" valign="top">file &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dc6/a00347.html">picotm-txmultiset.h</a></td></tr>
<tr class="memdesc:d1/dc6/a00347"><td class="mdescLeft">&#160;</td><td class="mdescRight">Provides transactional multisets. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The <code>struct txmultiset</code> data structure represents a transactional multiset (i.e., a set that can hold the same value multiple times). To create a multiset, we first need multiset entries. These are represented by <code>struct <a class="el" href="../../d2/d74/a00697.html" title="Represents an entry in a transaction-safe multiset. ">txmultiset_entry</a></code>. We can add an instance of this data structure to any data value to turn it into a multiset entry. Here's an example for multisets of values of type <code>unsigned long</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ulong_item {</div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d2/d74/a00697.html" title="Represents an entry in a transaction-safe multiset. ">txmultiset_entry</a> multiset_entry;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line">ulong_item_init(<span class="keyword">struct</span> ulong_item* item, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value)</div><div class="line">{</div><div class="line">    <a class="code" href="../../d8/d8e/a00344.html#a42874597d1eee621f937718f1383362f" title="Initializes an entry of a transactional multiset. ">txmultiset_entry_init</a>(&amp;item-&gt;multiset_entry);</div><div class="line">    item-&gt;value = value;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span>ulong_item item;</div><div class="line"></div><div class="line">ulong_item_init(&amp;item, 0);</div></div><!-- fragment --><p>This code initializes the multiset entry using <code><a class="el" href="../../d8/d8e/a00344.html#a42874597d1eee621f937718f1383362f" title="Initializes an entry of a transactional multiset. ">txmultiset_entry_init()</a></code>. The macro <code>TXMULTISET_ENTRY_INITIALIZER</code> initializes static or stack-allocated multiset entries. The example below illustrates this.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ulong_item {</div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d2/d74/a00697.html" title="Represents an entry in a transaction-safe multiset. ">txmultiset_entry</a> multiset_entry;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> value;</div><div class="line">};</div><div class="line"></div><div class="line"><span class="preprocessor">#define ULONG_ITEM_INITIALIZER(_value)  \</span></div><div class="line"><span class="preprocessor">{                                       \</span></div><div class="line"><span class="preprocessor">    TXMULTISET_ENTRY_INITIALIZER,       \</span></div><div class="line"><span class="preprocessor">    (_value)                            \</span></div><div class="line"><span class="preprocessor">}</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>ulong_item item = ULONG_ITEM_INITIALIZER(0);</div></div><!-- fragment --><p>When both, macro and function initialization, is possible, the macro form is prefered. Multiset entries are uninitialized with <code><a class="el" href="../../d8/d8e/a00344.html#a61ac83501e8f88eec6e6c734b42f8dc5" title="Cleans up an entry of a transactional multiset. ">txmultiset_entry_uninit()</a></code>.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">ulong_item_uninit(<span class="keyword">struct</span> ulong_item* item)</div><div class="line">{</div><div class="line">    <a class="code" href="../../d8/d8e/a00344.html#a61ac83501e8f88eec6e6c734b42f8dc5" title="Cleans up an entry of a transactional multiset. ">txmultiset_entry_uninit</a>(&amp;item-&gt;multiset_entry);</div><div class="line">}</div><div class="line"></div><div class="line">ulong_item_uninit(&amp;item);</div></div><!-- fragment --><p>To store the multiset entries, we need a non-transactional multiset state, which represents the shared state of a multiset. It's implemented by <code>struct <a class="el" href="../../d7/df1/a00705.html" title="The global state of transaction-safe multiset. ">txmultiset_state</a></code>. We can define and initialize a multiset state as illustrated in the example below.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span>ulong_item*</div><div class="line">ulong_item_of_entry(<span class="keyword">struct</span> <a class="code" href="../../d2/d74/a00697.html" title="Represents an entry in a transaction-safe multiset. ">txmultiset_entry</a>* entry)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="../../d2/de7/a00014.html#ac5d7110fe4aca39bb1fce3b46b2a1c3c">picotm_containerof</a>(entry, <span class="keyword">struct</span> ulong_item, multiset_entry);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">void</span>*</div><div class="line">ulong_item_key(<span class="keyword">struct</span> ulong_item* item)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> &amp;item-&gt;value;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">ulong_compare(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* lhs, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>* rhs)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> (*rhs &lt; *lhs) - (*lhs &lt; *rhs);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">void</span>*</div><div class="line">key_cb(<span class="keyword">struct</span> <a class="code" href="../../d2/d74/a00697.html" title="Represents an entry in a transaction-safe multiset. ">txmultiset_entry</a>* entry)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> ulong_item_key(ulong_item_of_entry(entry));</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">int</span></div><div class="line">compare_cb(<span class="keyword">const</span> <span class="keywordtype">void</span>* lhs, <span class="keyword">const</span> <span class="keywordtype">void</span>* rhs)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> ulong_compare(lhs, rhs);;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">struct </span><a class="code" href="../../d7/df1/a00705.html" title="The global state of transaction-safe multiset. ">txmultiset_state</a> multiset_state;</div><div class="line"></div><div class="line"><a class="code" href="../../d8/d8e/a00344.html#affc2e13fca3558940fdeda99293662a8" title="Initializes multiset state. ">txmultiset_state_init</a>(&amp;multiset_state, key_cb, compare_cb);</div></div><!-- fragment --><p>The initializer function takes the multiset state and two additional call-back functions, which are required for sorting the multiset's entries. The <code>key_cb()</code> call-back function returns a pointer to the key for a given entry. In the example above, it's the value itself. The <code>compare_cb()</code> call-back function compares two keys. It returns a value less than, equal to, or greater than zero if the left-hand-side value is less than, equal to, or greater than the right-hand-side value. Entries in a multiset are sorted by their key in ascending order. These call-back functions provide the key and the compare operation.</p>
<p>The code uses the initializer function <code><a class="el" href="../../d8/d8e/a00344.html#affc2e13fca3558940fdeda99293662a8" title="Initializes multiset state. ">txmultiset_state_init()</a></code>. For static or stack-allocated multiset states, there's the initializer macro <code><a class="el" href="../../d8/d8e/a00344.html#a66e2991f1fa69e7781efc0c48fe827e3" title="Initializer macro for struct txmultiset_state. ">TXMULTISET_STATE_INITIALIZER()</a></code>.</p>
<div class="fragment"><div class="line"><span class="keyword">struct </span><a class="code" href="../../d7/df1/a00705.html" title="The global state of transaction-safe multiset. ">txmultiset_state</a> multiset_state = <a class="code" href="../../d8/d8e/a00344.html#a66e2991f1fa69e7781efc0c48fe827e3" title="Initializer macro for struct txmultiset_state. ">TXMULTISET_STATE_INITIALIZER</a>(multiset_state, key_cb, compare_cb);</div></div><!-- fragment --><p>When both forms are possible, the initializer macro is prefered.</p>
<p>Multiset-state clean-up is performed by <code><a class="el" href="../../d8/d8e/a00344.html#a4cbbf2ceecaba2b80587283902cb4a82" title="Cleans up multiset state. ">txmultiset_state_uninit()</a></code>. The multiset state may not contain entries when the clean-up happens. This means that entries have to be removed from within a transaction.</p>
<p>For many uses this requirement just imposes unnecessary overhead. A call to <code><a class="el" href="../../d8/d8e/a00344.html#ab7441c7531c7c3b5aa216923cf4c7ce8" title="Removes all entries from a multiset state and runs a cleanup function on each. ">txmultiset_state_clear_and_uninit_entries()</a></code> provies a non-transactional way of clearing the multiset from its entries. It erases each element from the multiset and calls a clean-up function on it. The example below shows the clean-up code for a multiset of <code>struct ulong_item</code> entries.</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span></div><div class="line">ulong_item_uninit_cb(<span class="keyword">struct</span> <a class="code" href="../../d2/d74/a00697.html" title="Represents an entry in a transaction-safe multiset. ">txmultiset_entry</a>* entry, <span class="keywordtype">void</span>* data)</div><div class="line">{</div><div class="line">    ulong_item_uninit(ulong_item_of_entry(entry));</div><div class="line"></div><div class="line">    <span class="comment">// call free() if item was malloc()&#39;ed</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="../../d8/d8e/a00344.html#ab7441c7531c7c3b5aa216923cf4c7ce8" title="Removes all entries from a multiset state and runs a cleanup function on each. ">txmultiset_state_clear_and_uninit_entries</a>(&amp;multiset_state, ulong_item_uninit_cb, NULL);</div><div class="line"><a class="code" href="../../d8/d8e/a00344.html#a4cbbf2ceecaba2b80587283902cb4a82" title="Cleans up multiset state. ">txmultiset_state_uninit</a>(&amp;multiset_state);</div></div><!-- fragment --><p>At this point we have a multiset state and multiset entries to add to the state. So far all code was non-transactional. Actual multiset access and manipulation is performed by transactional code.</p>
<p>To perform multiset operations within a transaction, we first need a multiset data structure for our transaction. It's represented by <code>struct txmultiset</code>. A call to <code><a class="el" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx()</a></code> returns an instance.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/d82/a00857.html" title="A handle for operating on transaction-safe multisets. ">txmultiset</a>* multiset = <a class="code" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx</a>(&amp;multiset_state);</div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>Calling <code><a class="el" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx()</a></code> multiple times for the same multiset state <em>within the same transaction</em> returns the same multiset. Multisets are undefined after their transaction committed or aborted, or within other, concurrent transactions.</p>
<p>With the multiset, we can now insert entries into the multiset state using <code><a class="el" href="../../d1/dc6/a00347.html#a10720aa25e2b5ad6bbfca19cbc850bfa" title="Inserts an entry into a transactional multiset. ">txmultiset_insert_tx()</a></code>. The example below illustrates this.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/d82/a00857.html" title="A handle for operating on transaction-safe multisets. ">txmultiset</a>* multiset = <a class="code" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx</a>(&amp;multiset_state);</div><div class="line"></div><div class="line">    <a class="code" href="../../d1/dc6/a00347.html#a10720aa25e2b5ad6bbfca19cbc850bfa" title="Inserts an entry into a transactional multiset. ">txmultiset_insert_tx</a>(multiset, &amp;item-&gt;multiset_entry);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>After this transaction committed, the ulong data item <code>item</code> will be the in <code>multiset_state</code>. If the transactions has to abort after the call to <code><a class="el" href="../../d1/dc6/a00347.html#a10720aa25e2b5ad6bbfca19cbc850bfa" title="Inserts an entry into a transactional multiset. ">txmultiset_insert_tx()</a></code>, the transaction framework will automatically remove the entry during the rollback; thus restoring the original state.</p>
<p>The inserted entry will be sorted in ascending order into the multiset, using the key the compare call-back functions. The insert function compares the key of the new entry to the keys of existing entries to determines the new entry's position. The set is implemented as a tree, so inserting requires a compare operation with only a small fraction of existing items.</p>
<p>To remove an entry from the multiset, we can call <code><a class="el" href="../../d1/dc6/a00347.html#a539efd0ca9df1d533283149964933dc2" title="Removes an entry from a transactional multiset. ">txmultiset_erase_tx()</a></code>, as illustated in the example below.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/d82/a00857.html" title="A handle for operating on transaction-safe multisets. ">txmultiset</a>* multiset = <a class="code" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx</a>(&amp;multiset_state);</div><div class="line"></div><div class="line">    <span class="comment">// The multiset state already contains the entry.</span></div><div class="line">    <a class="code" href="../../d1/dc6/a00347.html#a539efd0ca9df1d533283149964933dc2" title="Removes an entry from a transactional multiset. ">txmultiset_erase_tx</a>(multiset, &amp;item-&gt;multiset_entry);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>Removing an entry keeps the entries sorted. The multiset's implementation re-arranges the entries automatically with very little overhead. As usual, all errors are detected and handled by the transaction framework. The benefits of transactional code show when we move entries between multisets.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/d82/a00857.html" title="A handle for operating on transaction-safe multisets. ">txmultiset</a>* src_multiset = <a class="code" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx</a>(&amp;src_multiset_state);</div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/d82/a00857.html" title="A handle for operating on transaction-safe multisets. ">txmultiset</a>* dst_multiset = <a class="code" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx</a>(&amp;dst_multiset_state);</div><div class="line"></div><div class="line">    <span class="comment">// The multiset state already contains the entry.</span></div><div class="line">    <a class="code" href="../../d1/dc6/a00347.html#a539efd0ca9df1d533283149964933dc2" title="Removes an entry from a transactional multiset. ">txmultiset_erase_tx</a>(src_multiset, &amp;item-&gt;multiset_entry);</div><div class="line"></div><div class="line">    <a class="code" href="../../d1/dc6/a00347.html#a10720aa25e2b5ad6bbfca19cbc850bfa" title="Inserts an entry into a transactional multiset. ">txmultiset_insert_tx</a>(dst_multiset, &amp;item-&gt;multiset_entry);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>In this example, we removed an entry from a source multiset and inserted it into a destination multiset. The transaction framework automatically isolates these operations from concurrent transactions until the transaction commits. So concurrent transactions see the entry in <em>either</em> the source multiset <em>or</em> the destination multiset, but never in both. If the transaction has to roll back after the insert operation, the transaction framework automatically removes the multiset entry from the destination multiset and returns it to its old position in the source multiset.</p>
<p>A call to <code><a class="el" href="../../d1/dc6/a00347.html#ab096b01886658c03bdf32ba9d0de4956" title="Returns the number of entries in a transactional multiset. ">txmultiset_size_tx()</a></code> returns the number of multiset entries, a call to <code><a class="el" href="../../d1/dc6/a00347.html#a8db34a07062dc8aad6a033094bf63d72" title="Tests a transactional multiset for emptiness. ">txmultiset_empty_tx()</a></code> returns <code>true</code> if a multiset is empty. The former function might have linear complexity, the later function always has constant complexity. It's therefore better to use <code><a class="el" href="../../d1/dc6/a00347.html#a8db34a07062dc8aad6a033094bf63d72" title="Tests a transactional multiset for emptiness. ">txmultiset_empty_tx()</a></code> if it's only relevant whether there are entries.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/d82/a00857.html" title="A handle for operating on transaction-safe multisets. ">txmultiset</a>* multiset = <a class="code" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx</a>(&amp;multiset_state);</div><div class="line"></div><div class="line">    <span class="keywordtype">bool</span> is_empty = <a class="code" href="../../d1/dc6/a00347.html#a8db34a07062dc8aad6a033094bf63d72" title="Tests a transactional multiset for emptiness. ">txmultiset_empty_tx</a>(multiset);</div><div class="line"></div><div class="line">    <span class="keywordtype">size_t</span> size = <a class="code" href="../../d1/dc6/a00347.html#ab096b01886658c03bdf32ba9d0de4956" title="Returns the number of entries in a transactional multiset. ">txmultiset_size_tx</a>(multiset);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>We can iterate over the entries of a multiset. The first entry of the multiset is returned by <code><a class="el" href="../../d1/dc6/a00347.html#a1fbb5811dd34dfe06246ff47edd81649" title="Returns the first entry of a transactional multiset. ">txmultiset_begin_tx()</a></code>. The terminator entry <em>after</em> the final entry is returned by <code><a class="el" href="../../d1/dc6/a00347.html#adc69682d0870ef3c8079cd9cf65e0396" title="Returns the terminator of a transactional multiset. ">txmultiset_end_tx()</a></code>. The terminator entry is not a real entry and should not be dereferenced. Calls to <code><a class="el" href="../../d8/d8e/a00344.html#ae423cf249753d786d03f89c5659dbc16" title="Returns the next multiset entry. ">txmultiset_entry_next_tx()</a></code> and <code><a class="el" href="../../d8/d8e/a00344.html#a915a46ec0de2ee4169765ff52b7a2f51" title="Returns the previous multiset entry. ">txmultiset_entry_prev_tx()</a></code> return an entry's successor or predecessor. Here's an example that iterates over a multiset of values of type <code>unsigned long</code> and sums up the individual values.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> g_sum; <span class="comment">// global variable containg sum of multiset entries</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/d82/a00857.html" title="A handle for operating on transaction-safe multisets. ">txmultiset</a>* multiset = <a class="code" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx</a>(&amp;multiset_state);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> sum = 0;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d2/d74/a00697.html" title="Represents an entry in a transaction-safe multiset. ">txmultiset_entry</a>* beg = <a class="code" href="../../d1/dc6/a00347.html#a1fbb5811dd34dfe06246ff47edd81649" title="Returns the first entry of a transactional multiset. ">txmultiset_begin_tx</a>(multiset);</div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d2/d74/a00697.html" title="Represents an entry in a transaction-safe multiset. ">txmultiset_entry</a>* end = <a class="code" href="../../d1/dc6/a00347.html#adc69682d0870ef3c8079cd9cf65e0396" title="Returns the terminator of a transactional multiset. ">txmultiset_end_tx</a>(multiset);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (beg != end) {</div><div class="line"></div><div class="line">        <span class="keyword">struct </span>ulong_item* item = ulong_item_of_entry(beg);</div><div class="line"></div><div class="line">        sum += item-&gt;value;</div><div class="line"></div><div class="line">        beg = <a class="code" href="../../d8/d8e/a00344.html#ae423cf249753d786d03f89c5659dbc16" title="Returns the next multiset entry. ">txmultiset_entry_next_tx</a>(beg);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line">    <span class="comment">// Picotm&#39;s modules collaborate! The value stored in</span></div><div class="line">    <span class="comment">// `sum` is exported from the transaction state using</span></div><div class="line">    <span class="comment">// `store_ulong_tx()` from the Transactional Memory</span></div><div class="line">    <span class="comment">// module.</span></div><div class="line"></div><div class="line">    <a class="code" href="../../d5/d0f/a00308.html#ac001d9940eb6479334b1e2b9d8eb65f4">store_ulong_tx</a>(&amp;g_sum, sum);</div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>Being a sorted data structure, multisets offer efficient search operations. A call to <code><a class="el" href="../../d1/dc6/a00347.html#ada275b383a8fc7280b4b1cd286d2a361" title="Finds an entry with a specific key in a transactional multiset. ">txmultiset_find_tx()</a></code> looks-up an entry by a key. A multiset can contain multiple entries with the same key. In this case <code><a class="el" href="../../d1/dc6/a00347.html#ada275b383a8fc7280b4b1cd286d2a361" title="Finds an entry with a specific key in a transactional multiset. ">txmultiset_find_tx()</a></code> returns one of them. The exact entry can vary among calls.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/d82/a00857.html" title="A handle for operating on transaction-safe multisets. ">txmultiset</a>* multiset = <a class="code" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx</a>(&amp;multiset_state);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> key = 0;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d2/d74/a00697.html" title="Represents an entry in a transaction-safe multiset. ">txmultiset_entry</a>* entry = <a class="code" href="../../d1/dc6/a00347.html#ab096b01886658c03bdf32ba9d0de4956" title="Returns the number of entries in a transactional multiset. ">txmultiset_size_tx</a>(multiset, &amp;key);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>The beginning and end of a range of entries with the same key is be obtained by <code><a class="el" href="../../d1/dc6/a00347.html#a1402ff0aee264fac18bab0ad5c5ba2c1" title="Returns a transactional multiset&#39;s the first entry with a specific key. ">txmultiset_lower_bound_tx()</a></code> and <code><a class="el" href="../../d1/dc6/a00347.html#aab9d1b9aebc7387ef85c1c2e0f234f4f" title="Returns a transactional multiset&#39;s first entry with a key larger than a specific key. ">txmultiset_upper_bound_tx()</a></code>. The former returns the first entry with the specified key; the latter returns the entry after the final entry with the specified key. By iterating over the range, all entries with the key can be obtained.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/d82/a00857.html" title="A handle for operating on transaction-safe multisets. ">txmultiset</a>* multiset = <a class="code" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx</a>(&amp;multiset_state);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> key_count = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> key = 0;</div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d2/d74/a00697.html" title="Represents an entry in a transaction-safe multiset. ">txmultiset_entry</a>* beg = <a class="code" href="../../d1/dc6/a00347.html#a1402ff0aee264fac18bab0ad5c5ba2c1" title="Returns a transactional multiset&#39;s the first entry with a specific key. ">txmultiset_lower_bound_tx</a>(multiset, &amp;key);</div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d2/d74/a00697.html" title="Represents an entry in a transaction-safe multiset. ">txmultiset_entry</a>* end = <a class="code" href="../../d1/dc6/a00347.html#aab9d1b9aebc7387ef85c1c2e0f234f4f" title="Returns a transactional multiset&#39;s first entry with a key larger than a specific key. ">txmultiset_upper_bound_tx</a>(multiset, &amp;key);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span> (beg != end) {</div><div class="line"></div><div class="line">        ++key_count;</div><div class="line"></div><div class="line">        beg = <a class="code" href="../../d8/d8e/a00344.html#ae423cf249753d786d03f89c5659dbc16" title="Returns the next multiset entry. ">txmultiset_entry_next_tx</a>(beg);</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="comment">// ... more transactional code ...</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>The above example counts the number of entries for the given key. The function <code><a class="el" href="../../d1/dc6/a00347.html#af1fe06f1dfb1e328e2442fc731bfb3ac" title="Returns the number of entries with a specfic key in a transactional multiset. ">txmultiset_count_tx()</a></code> performs this operation more efficiently.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/d82/a00857.html" title="A handle for operating on transaction-safe multisets. ">txmultiset</a>* multiset = <a class="code" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx</a>(&amp;multiset_state);</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> key = 0;</div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> key_count = <a class="code" href="../../d1/dc6/a00347.html#af1fe06f1dfb1e328e2442fc731bfb3ac" title="Returns the number of entries with a specfic key in a transactional multiset. ">txmultiset_count_tx</a>(multiset, &amp;key);</div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --><p>Finally, to clear the whole multiset at once, there's <code><a class="el" href="../../d1/dc6/a00347.html#a512a3476bde5ec7c2db030e0cc329ee8" title="Removes all entries from a transactional multiset. ">txmultiset_clear_tx()</a></code>. It's equivalent to a continuous erase operation, but prefered for its reduced overhead.</p>
<div class="fragment"><div class="line"><span class="comment">// init and ulong code here</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc4de35068696187a89ba73ff54f2c82">picotm_begin</a></div><div class="line"></div><div class="line">    <span class="keyword">struct </span><a class="code" href="../../d0/d82/a00857.html" title="A handle for operating on transaction-safe multisets. ">txmultiset</a>* multiset = <a class="code" href="../../d1/dc6/a00347.html#a0c74edb20c492af4005f69b41e83ddfa" title="Creates a transactional multiset for a multiset state. ">txmultiset_of_state_tx</a>(&amp;multiset_state);</div><div class="line"></div><div class="line">    <a class="code" href="../../d1/dc6/a00347.html#a512a3476bde5ec7c2db030e0cc329ee8" title="Removes all entries from a transactional multiset. ">txmultiset_clear_tx</a>(multiset);</div><div class="line"></div><div class="line">    <span class="comment">// more transactional code</span></div><div class="line"></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#aa2a3ff1fd64dd3038cb3e863da12f1c9">picotm_commit</a></div><div class="line"><a class="code" href="../../d9/d22/a00873.html#acc10340471b96a797fbf6610341bbe01">picotm_end</a></div></div><!-- fragment --> </div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="../../doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
